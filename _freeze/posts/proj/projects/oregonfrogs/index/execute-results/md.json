{
  "hash": "08643cab49753fe890964e4162edfa4b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Oregon spotted a frog: Rana Pretiosa'\nauthor: \"Federica Gazzelloni\"\ndate: \"2022-10-30\"\nformat: hugo\nexcerpt: Machine Learning with mlr3\ndraft: no\nimages: null\nseries: null\ntags:\n  - rstats\n  - mlr3\ncategories: null\nlayout: single\nexecute: \n  eval: false\n---\n\n\n\n\n#### Updated June 2023\n\n# Overview\n\nI made a package! Looking for data to use for one of my data visualization I stomped into this data about frogs in Oregon (US) and realized that it was very interesting for making both classification and regression models.\n\n![](featured.png)\n\nSo, I wrapped the data into a package, and even if it is still a work in progress I started using it for practicing **machine learning** algorithms.\n\nMore info about it will follow. For now this project is all about how to use {mlr3} package for analysing and predicting data.\n\n**mlr3** is a machine learning **ecosystem**, it provides a unified interface to use different machine learning models in R.\n\nLet's load the libraries, and start using **mlr3** with **oregonfrogs** data!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(mlr3)\n# remotes::install_github(\"mlr-org/mlr3spatiotempcv\")\nlibrary(mlr3spatiotempcv)\nlibrary(mlr3learners) # needed to initiate a new learner (such as classif.ranger)\n# remotes::install_github(\"mlr-org/mlr3extralearners\")\nlibrary(mlr3extralearners)\nlibrary(ranger)\n# install.packages(\"apcluster\")\n# remotes::install_github(\"mlr-org/mlr3proba\")\nlibrary(\"mlr3viz\")\n```\n:::\n\n\nTo install {oregonfrogs}, which is still in its development version you need to install it from github:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"fgazzelloni/oregonfrogs\")\nlibrary(oregonfrogs)\n```\n:::\n\n\nI changed the name of the dataset to **oregonfrogs**, so now is `oregonfrogs::oregonfrogs` also added some functions, made some modifications, and left the raw data (`oregonfrogs_raw`) available.\n\nHere, I take some selected variables which I'll use in the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noregonfrogs_raw %>%\n  head(3) %>%\n  select(3:4, 6:8, 10:11)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 7\n  HabType SurveyDate Frequency UTME_83 UTMN_83 Female Water        \n  <chr>   <chr>          <dbl>   <dbl>   <dbl>  <dbl> <chr>        \n1 Pond    9/25/2018       164.  597369 4846486      0 Deep water   \n2 Pond    10/2/2018       164.  597352 4846487      0 Deep water   \n3 Pond    10/9/2018       164.  597345 4846458      0 Shallow water\n```\n\n\n:::\n:::\n\n\nIt's a practical use to change the *utm* coordinates into *longlat*. The package include these changes in the *oregonfrogs* dataset. As well as, I added a couple of functions that let the user switch back and forth between coordinate systems, `utm_to_longlat` and `longlat_to_utm`.\n\nThis is basically what the `utm_to_longlat()` function does:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noregonfrogs <- oregonfrogs_raw %>%\n  dplyr::select(UTME_83, UTMN_83) %>%\n  sf::st_as_sf(coords = c(1, 2),\n               crs = \"+proj=utm +zone=10\") %>%\n  sf::st_transform(crs = \"+proj=longlat +datum=WGS84\")  %>%\n  sf::st_coordinates() %>%\n  cbind(oregonfrogs_raw) %>%\n  mutate(\n    SurveyDate = as.Date(SurveyDate, \"%m/%d/%Y\"),\n    month = lubridate::month(SurveyDate),\n    Water = as.factor(Water)\n  ) %>%\n  select(-SurveyDate,-UTME_83,-UTMN_83,-Site)\n```\n:::\n\n\nAnd here is a spec of the two systems in comparison for the **oregonfrogs** data:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  UTME_83 UTMN_83         X        Y\n1  597369 4846486 -121.7903 43.76502\n2  597352 4846487 -121.7905 43.76503\n3  597345 4846458 -121.7906 43.76477\n4  597340 4846464 -121.7907 43.76483\n5  597344 4846460 -121.7906 43.76479\n6  597410 4846451 -121.7898 43.76470\n```\n\n\n:::\n:::\n\n\n### Set a Task\n\nThe **mlr3 package** provides a `task()` function, which allows to set the data to use inside the selected model.\n\nMore specifically, here is used `mlr3spatiotempcv::TaskClassifST()` specific for **spatial classification** modeling tasks.\n\nAmong the function's *options*, there are:\n\n-   *id*: the identification of the location,\n-   *backend*: the data to use in the model\n-   *target*: the response variable\n-   ...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntask = mlr3spatiotempcv::TaskClassifST$new(\n  id = \"lake\",\n  backend = mlr3::as_data_backend(oregonfrogs),\n  target = \"Water\",\n  #positive = \"FALSE\",  ### ????\n  coordinate_names = c(\"X\", \"Y\"),\n  coords_as_features = TRUE,\n  crs = \"+proj=longlat +datum=WGS84\"   # \"+proj=utm +zone=10\"\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n### Set the Learner\n\nThe second step is to set the **learner**: `mlr3::lrn()`\n\nThis is the model type and prediction outcome type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# model type\n# mlr_learners$get(\"classif.ranger\")\nlearner = mlr3::lrn(\"classif.ranger\", predict_type = \"prob\")\n# learner$help()\nlearner\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<LearnerClassifRanger:classif.ranger>: Random Forest\n* Model: -\n* Parameters: num.threads=1\n* Packages: mlr3, mlr3learners, ranger\n* Predict Types:  response, [prob]\n* Feature Types: logical, integer, numeric, character, factor, ordered\n* Properties: hotstart_backward, importance, multiclass, oob_error,\n  twoclass, weights\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlearner$param_set\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlearner$train(task)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlearner$model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRanger result\n\nCall:\n ranger::ranger(dependent.variable.name = task$target_names, data = task$data(),      probability = self$predict_type == \"prob\", case.weights = task$weights$weight,      num.threads = 1L) \n\nType:                             Probability estimation \nNumber of trees:                  500 \nSample size:                      311 \nNumber of independent variables:  14 \nMtry:                             3 \nTarget node size:                 10 \nVariable importance mode:         none \nSplitrule:                        gini \nOOB prediction error (Brier s.):  0.1474721 \n```\n\n\n:::\n:::\n\n\n### Predict\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction <- learner$predict_newdata(oregonfrogs)\nmeasure = msr(\"classif.acc\")\nprediction$score(measure)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclassif.acc \n  0.9549839 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction$confusion\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               truth\nresponse        Deep water No water Shallow water Unknown water\n  Deep water            76        0             6             1\n  No water               0       10             0             0\n  Shallow water          5        2           194             0\n  Unknown water          0        0             0            17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmlr3viz::autoplot(prediction)\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-15-1.png){width=768}\n:::\n:::\n\n\n### Resampling\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# resampling\nresampling = mlr3::rsmp(\"repeated_spcv_coords\",\n                        folds = 5,\n                        repeats = 100)\nresampling\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<ResamplingRepeatedSpCVCoords>: Repeated coordinate-based k-means clustering resampling\n* Iterations: 500\n* Instantiated: FALSE\n* Parameters: folds=5, repeats=100\n```\n\n\n:::\n:::\n\n\nA **logging record** can be set for debugging in case model crashes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n```\n:::\n\n\nParallelization:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparallelly::availableCores()\nset_threads(learner)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# fit resamples\ntime = Sys.time()\nrr_spcv_ranger = mlr3::resample(task = task,\n                                learner = learner,\n                                resampling = resampling)\nSys.time() - time\n```\n:::\n\n\nTime difference of 48.01483 secs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrr_spcv_ranger\nrr_spcv_ranger$score() \n```\n:::\n\n\n### Model evaluation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# accuracy\nscore_spcv_ranger = rr_spcv_ranger$score(measure = mlr3::msr(\"classif.acc\")) %>%\n  select(task_id, learner_id, resampling_id, classif.acc)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# avg accuracy\nmean(score_spcv_ranger$classif.acc) %>%\n  round(2)  # 0.64\n```\n:::\n\n\n## Machine Learning\n\n### Tuning: Tweaking the hyperparameters of the learner\n\nIn **random forests**, the hyperparameters *mtry*, *min.node.size* and *sample.fraction* determine the degree of randomness, and should be tuned. This is when **machine learning** comes into play.\n\nHyperparameters:\n\n-   **mtry** indicates how many predictor variables should be used in each tree\n-   **sample.fraction** parameter specifies the fraction of observations to be used in each tree\n-   **min.node.size** parameter indicates the number of observations a terminal node should at least have\n\nsource: <https://geocompr.robinlovelace.net/eco.html>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### tuning\ntune_level = mlr3::rsmp(\"spcv_coords\", folds = 5)\n\nterminator = mlr3tuning::trm(\"evals\", n_evals = 50)\n\ntuner = mlr3tuning::tnr(\"random_search\")\n```\n:::\n\n\n#### Search space\n\nTo specify tuning limits `paradox::ps()` is used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch_space =\n  paradox::ps(\n    mtry = paradox::p_int(lower = 1,\n                          upper = ncol(task$data()) - 1),\n    sample.fraction = paradox::p_dbl(lower = 0.2,\n                                     upper = 0.9),\n    min.node.size = paradox::p_int(lower = 1,\n                                   upper = 10)\n  )\nsearch_space\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<ParamSet>\n                id    class lower upper nlevels        default value\n1:            mtry ParamInt   1.0  14.0      14 <NoDefault[3]>      \n2: sample.fraction ParamDbl   0.2   0.9     Inf <NoDefault[3]>      \n3:   min.node.size ParamInt   1.0  10.0      10 <NoDefault[3]>      \n```\n\n\n:::\n:::\n\n\n#### Automation\n\nAutomated tuning specification via the `mlr3tuning::AutoTuner()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautotuner_rf =\n  mlr3tuning::AutoTuner$new(\n    learner = learner,\n    store_benchmark_result = TRUE,\n    resampling = mlr3::rsmp(\"spcv_coords\",\n                            folds = 5),\n    # spatial partitioning\n    measure = mlr3::msr(\"classif.acc\"),\n    # performance measure\n    terminator = mlr3tuning::trm(\"evals\",\n                                 n_evals = 50),\n    # specify 50 iterations\n    search_space = search_space,\n    # predefined hyperparameter search space\n    tuner = mlr3tuning::tnr(\"random_search\") # specify random search\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# hyperparameter tuning\ntime = Sys.time()\n\nset.seed(0412022)\nautotuner_rf$train(task)\n\nSys.time() - time\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautotuner_rf$tuning_result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   mtry sample.fraction min.node.size learner_param_vals  x_domain classif.acc\n1:   14       0.4857718             1          <list[4]> <list[3]>   0.7801733\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautotuner_rf$predict(task)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<PredictionClassif> for 311 observations:\n    row_ids         truth      response prob.Deep water prob.No water\n          1    Deep water    Deep water           0.674         0.016\n          2    Deep water    Deep water           0.856         0.016\n          3 Shallow water    Deep water           0.502         0.000\n---                                                                  \n        309 Unknown water Unknown water           0.298         0.040\n        310 Unknown water Unknown water           0.072         0.340\n        311      No water      No water           0.092         0.546\n    prob.Shallow water prob.Unknown water\n                 0.308              0.002\n                 0.118              0.010\n                 0.492              0.006\n---                                      \n                 0.060              0.602\n                 0.066              0.522\n                 0.110              0.252\n```\n\n\n:::\n\n```{.r .cell-code}\n# pred = terra::predict(..., model = autotuner_rf, fun = predict)\n\n# save.image(\"data/oregonfrogs_mlr3.RData\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- autotuner_rf$predict(task)\nautoplot(res)\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-29-1.png){width=768}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres %>%\n  fortify() %>%\n  pivot_longer(cols = starts_with(\"prob\"),\n               names_to = \"prob_type\",\n               values_to = \"prob\") %>%\n  mutate(prob_type = gsub(\"prob.\", \"\", prob_type)) %>%\n  ggplot(aes(prob, group = prob_type, fill = prob_type)) +\n  geom_density(alpha = 0.5) +\n  facet_wrap(vars(prob_type), scales = \"free\") +\n  labs(fill = \"Water Type\", x = \"Probability\", y = \"Density\") +\n  scale_fill_viridis_d() +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-30-1.png){width=768}\n:::\n:::\n",
    "supporting": [
      "index.markdown_strict_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}